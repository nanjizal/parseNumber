class haxe.Int64Helper {

	public static function parseString(sParam:String) {
		var base = haxe._Int64.Int64_Impl_.ofInt(10);
		var current = haxe._Int64.Int64_Impl_.ofInt(0);
		var multiplier = haxe._Int64.Int64_Impl_.ofInt(1);
		var sIsNegative = false;
		var s = StringTools.trim(sParam);
		if (s.charAt(0) == "-") {
			sIsNegative = true;
			s = s.substring(1, s.length);
		};
		var len = s.length;
		{
			var ` = 0;
			var `1 = len;
			while (` < `1) {
				var i = ` ++;
				var digitInt = s.charCodeAt(len - 1 - i) - 48;
				if (digitInt < 0 || digitInt > 9) {
					throw throw haxe.Exception.thrown("NumberFormatError");
				};
				if (digitInt != 0) {
					var digit = haxe._Int64.Int64_Impl_.ofInt(digitInt);
					if (sIsNegative) {
						current = haxe._Int64.Int64_Impl_.sub(current, haxe._Int64.Int64_Impl_.mul(multiplier, digit));
						if (! haxe._Int64.Int64_Impl_.isNeg(current)) {
							throw throw haxe.Exception.thrown("NumberFormatError: Underflow");
						};
					} else {
						current = haxe._Int64.Int64_Impl_.add(current, haxe._Int64.Int64_Impl_.mul(multiplier, digit));
						if (haxe._Int64.Int64_Impl_.isNeg(current)) {
							throw throw haxe.Exception.thrown("NumberFormatError: Overflow");
						};
					};
				};
				multiplier = haxe._Int64.Int64_Impl_.mul(multiplier, base);
			};
		};
		return current;
	}

	public static function fromFloat(f:Float) {
		if (Math.isNaN(f) || ! Math.isFinite(f)) {
			throw throw haxe.Exception.thrown("Number is NaN or Infinite");
		};
		var noFractions = f - (f % 1);
		if (noFractions > 9007199254740991) {
			throw throw haxe.Exception.thrown("Conversion overflow");
		};
		if (noFractions < -9007199254740991) {
			throw throw haxe.Exception.thrown("Conversion underflow");
		};
		var result = haxe._Int64.Int64_Impl_.ofInt(0);
		var neg = noFractions < 0;
		var rest = if (neg) {
			- noFractions;
		} else {
			noFractions;
		};
		var i = 0;
		while (rest >= 1) {
			var curr = rest % 2;
			rest = rest / 2;
			if (curr >= 1) {
				result = haxe._Int64.Int64_Impl_.add(result, haxe._Int64.Int64_Impl_.shl(haxe._Int64.Int64_Impl_.ofInt(1), i));
			};
			i ++;
		};
		if (neg) {
			result = haxe._Int64.Int64_Impl_.neg(result);
		};
		return result;
	}
}