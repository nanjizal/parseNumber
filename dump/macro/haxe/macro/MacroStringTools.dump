class haxe.macro.MacroStringTools {

	public static function formatString(s:String, pos:haxe.macro.Position) {
		return haxe.macro.Context.load("format_string", 2)(s, pos);
	}

	public static function isFormatExpr(e:haxe.macro.ExprOf<String>) {
		return {
			var ` = e.expr;
			if (enumIndex ` == 0) {
				var `1 = `[0];
				if (enumIndex `1 == 2) {
					var `2 = `1[0];
					var `3 = `1[1];
					if (`3 == null) false else if (enumIndex `3 == 1) {
						true;
					} else false;
				} else false;
			} else false;
		};
	}

	@:has_untyped
	public static function toFieldExpr(sl:Array<String>, pos:Null<haxe.macro.Position> = null) {
		if (pos == null) {
			return Lambda.fold(sl, function(s:String, e:haxe.macro.Expr) return if (e == null) {
				(cast {expr : haxe.macro.ExprDef.EConst(haxe.macro.Constant.CIdent(s)), pos : $__mk_pos__("/usr/local/lib/haxe/std/haxe/macro/MacroStringTools.hx", 2307, 2310)});
			} else {
				(cast {expr : haxe.macro.ExprDef.EField(e, s), pos : $__mk_pos__("/usr/local/lib/haxe/std/haxe/macro/MacroStringTools.hx", 2321, 2326)});
			}, null);
		};
		var e = null;
		{
			var ` = 0;
			while (` < sl.length) {
				var v = sl[`];
				++ `;
				if (e == null) {
					e = {expr : haxe.macro.ExprDef.EConst(haxe.macro.Constant.CIdent(v)), pos : pos};
				} else {
					e = {expr : haxe.macro.ExprDef.EField(e, v), pos : pos};
				};
			};
		};
		return e;
	}

	public static function toDotPath(pack:Array<String>, name:String) {
		return if (pack.length == 0) {
			name;
		} else {
			pack.join(".") + "." + name;
		};
	}

	public static function toComplex(path:String) {
		var pack = path.split(".");
		return haxe.macro.ComplexType.TPath({pack : pack, name : pack.pop(), params : []});
	}
}