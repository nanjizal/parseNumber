@:access(utest.Runner.iTestFixtures) @:access(utest.Runner.runNext) @:access(utest.Runner.runFixture) @:access(utest.Runner.executedFixtures)
private class utest._Runner.ITestRunner {

	public function new(runner:utest.Runner) {
		this.runner = runner;
	}

	var runner:utest.Runner;

	var cases:Iterator<utest.ITest>;

	var currentCase:utest.ITest;

	var currentCaseFixtures:Array<utest.TestFixture>;

	var teardownClass:() -> utest.Async;

	var setupAsync:utest.Async;

	var teardownAsync:utest.Async;

	public function run() {
		this.cases = haxe.ds._Map.Map_Impl_.keys(this.runner.iTestFixtures);
		this.runCases();
	}

	function runCases() {
		while (this.cases.hasNext()) {
			this.currentCase = this.cases.next();
			var data = haxe.ds._Map.Map_Impl_.get(this.runner.iTestFixtures, this.currentCase);
			this.currentCaseFixtures = data.fixtures;
			this.teardownClass = data.teardownClass;
			try {
				this.setupAsync = data.setupClass();
			} catch (`:Dynamic) {
				var ` = haxe.Exception.caught(`);
				var ` = `.unwrap();
				if (true) {
					var e = `;
					{
						this.setupFailed(utest.Assertation.SetupError("setupClass failed: " + Std.string(e), haxe._CallStack.CallStack_Impl_.exceptionStack(null)));
						return;
					};
				} else throw `;
			};
			if (this.setupAsync.resolved) {
				if (! this.runFixtures(null)) {
					return;
				};
			} else {
				this.setupAsync.then(this.checkSetup);
				return;
			};
		};
		this.runner.runNext(null);
	}

	function checkSetup() {
		if (this.setupAsync.timedOut) {
			this.setupFailed(utest.Assertation.SetupError("setupClass timeout", []));
		} else {
			this.runFixtures(null);
		};
	}

	function setupFailed(assertation:utest.Assertation) {
		var fh = this.runner;
		fh.executedFixtures += this.currentCaseFixtures.length;
		this.runner.onProgress.dispatch({totals : this.runner.length, result : utest.TestResult.ofFailedSetupClass(this.currentCase, assertation), done : this.runner.executedFixtures});
		this.runCases();
	}

	function runFixtures(finishedHandler:Null<utest.TestHandler<utest.TestFixture>> = null) {
		while (this.currentCaseFixtures.length > 0) {
			var handler = this.runner.runFixture(this.currentCaseFixtures.pop());
			if (! handler.finished) {
				handler.onComplete.add(this.runFixtures);
				return false;
			};
		};
		try {
			this.teardownAsync = this.teardownClass();
		} catch (`:Dynamic) {
			var ` = haxe.Exception.caught(`);
			var ` = `.unwrap();
			if (true) {
				var e = `;
				{
					this.teardownFailed(utest.Assertation.TeardownError("tearDownClass failed: " + Std.string(e), haxe._CallStack.CallStack_Impl_.exceptionStack(null)));
				};
			} else throw `;
		};
		if (this.teardownAsync.resolved && finishedHandler == null) {
			return true;
		};
		this.teardownAsync.then(this.checkTeardown);
		return false;
	}

	function checkTeardown() {
		if (this.teardownAsync.timedOut) {
			this.teardownFailed(utest.Assertation.TeardownError("teardownClass timeout", []));
		};
		this.runCases();
	}

	function teardownFailed(assertation:utest.Assertation) {
		this.runner.onProgress.dispatch({totals : this.runner.length, result : utest.TestResult.ofFailedTeardownClass(this.currentCase, assertation), done : this.runner.executedFixtures});
	}
}