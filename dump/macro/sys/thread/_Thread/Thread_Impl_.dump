private class sys.thread._Thread.Thread_Impl_ {

	public static var events(get,never):sys.thread.EventLoop;

	@:noCompletion
	static inline function _new(h:eval.vm.NativeThread) {
		var this;
		this = h;
		return cast this;
	}

	public static inline function sendMessage(this:sys.thread._Thread.ThreadImpl, msg:Dynamic) {
		this.sendMessage(msg);
	}

	public static inline function current() {
		return sys.thread._Thread.Thread_Impl_._new(eval.vm.NativeThread.self());
	}

	public static inline function create(job:() -> Void) {
		return sys.thread._Thread.Thread_Impl_._new(new eval.vm.NativeThread(job));
	}

	public static function runWithEventLoop(job:() -> Void) {
		var thread = eval.vm.NativeThread.self();
		if (thread.get_events() == null) {
			thread.set_events(new sys.thread.EventLoop());
			try {
				job();
				thread.get_events().loop();
				thread.set_events(null);
			} catch (`:Dynamic) {
				var ` = haxe.Exception.caught(`);
				{};
				if (true) {
					var e = cast `;
					{
						thread.set_events(null);
						throw throw haxe.Exception.thrown(e);
					};
				} else throw `;
			};
		} else {
			job();
		};
	}

	public static inline function createWithEventLoop(job:() -> Void) {
		return sys.thread._Thread.Thread_Impl_._new(new eval.vm.NativeThread(function() {
			var thread = eval.vm.NativeThread.self();
			thread.set_events(new sys.thread.EventLoop());
			job();
			thread.get_events().loop();
		}));
	}

	public static inline function readMessage(block:Bool) {
		return eval.vm.NativeThread.readMessage(block);
	}

	public static inline function yield() {
		eval.vm.NativeThread.yield();
	}

	@:op(A == B)
	public static inline function equals(this:sys.thread._Thread.ThreadImpl, other:sys.thread.Thread) {
		return sys.thread._Thread.Thread_Impl_.getHandle(this).id() == sys.thread._Thread.Thread_Impl_.getHandle(other).id();
	}

	static inline function getHandle(this:sys.thread._Thread.ThreadImpl) {
		return this;
	}

	static function get_events(this:sys.thread._Thread.ThreadImpl) {
		if (this.get_events() == null) {
			throw throw new sys.thread.NoEventLoopException(null, null);
		};
		return this.get_events();
	}

	@:keep
	static function processEvents() {
		eval.vm.NativeThread.self().get_events().loop();
	}

	static function __init__() {
		eval.vm.NativeThread.self().set_events(new sys.thread.EventLoop());
	}
}