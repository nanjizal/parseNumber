@:coreApi
class sys.thread.EventLoop {

	public function new() {
		this.looping = false;
		this.pending = [];
		this.promisedEventsCount = 0;
		this.oneTimeEventsIdx = 0;
		this.oneTimeEvents = new Array();
		this.mutex = new sys.thread.Mutex();
		this.handle = eval.luv.ResultTools.resolve(eval.luv._Loop.Loop_Impl_.init());
		this.wakeup = eval.luv.ResultTools.resolve(eval.luv._Async.Async_Impl_.init(this.handle, this.consumePending));
		eval.luv._Handle.Handle_Impl_.unref(this.wakeup);
	}

	@:allow(eval.luv.Loop)
	var handle(default,ctor):eval.luv.Loop;

	@:value(new Mutex())
	var mutex(default,ctor):sys.thread.Mutex;

	@:value(new Array<Null<Void -> Void>>())
	var oneTimeEvents(default,ctor):Array<Null<() -> Void>>;

	@:value(0)
	var oneTimeEventsIdx:Int;

	var wakeup(default,ctor):eval.luv.Async;

	@:value(0)
	var promisedEventsCount:Int;

	@:value([])
	var pending:Array<() -> Void>;

	@:value(false)
	var looping:Bool;

	public function repeat(event:() -> Void, intervalMs:Int) {
		var `this = this;
		var e = new sys.thread._EventLoop.RegularEvent(event);
		this.mutex.acquire();
		this.pending.push(function() {
			e.timer = eval.luv.ResultTools.resolve(eval.luv._Timer.Timer_Impl_.init(`this.handle));
			eval.luv.ResultTools.resolve(eval.luv._Timer.Timer_Impl_.start(e.timer, e.run, intervalMs, if (intervalMs < 1) {
				1;
			} else {
				intervalMs;
			}));
		});
		this.mutex.release();
		eval.luv._Async.Async_Impl_.send(this.wakeup);
		return e;
	}

	public function cancel(eventHandler:sys.thread.EventHandler) {
		this.mutex.acquire();
		(cast eventHandler).event = sys.thread.EventLoop.noop;
		this.pending.push(function() {
			var timer = (cast eventHandler).timer;
			eval.luv.ResultTools.resolve(eval.luv._Timer.Timer_Impl_.stop(timer));
			eval.luv._Handle.Handle_Impl_.close(timer, sys.thread.EventLoop.noop);
		});
		this.mutex.release();
		eval.luv._Async.Async_Impl_.send(this.wakeup);
	}

	public function promise() {
		this.mutex.acquire();
		++ this.promisedEventsCount;
		this.pending.push(this.refUnref);
		this.mutex.release();
		eval.luv._Async.Async_Impl_.send(this.wakeup);
	}

	public function run(event:() -> Void) {
		this.mutex.acquire();
		this.pending.push(event);
		this.mutex.release();
		eval.luv._Async.Async_Impl_.send(this.wakeup);
	}

	public function runPromised(event:() -> Void) {
		this.mutex.acquire();
		-- this.promisedEventsCount;
		this.pending.push(this.refUnref);
		this.pending.push(event);
		this.mutex.release();
		eval.luv._Async.Async_Impl_.send(this.wakeup);
	}

	function refUnref() {
		if (this.promisedEventsCount > 0) {
			eval.luv._Handle.Handle_Impl_.ref(this.wakeup);
		} else {
			eval.luv._Handle.Handle_Impl_.unref(this.wakeup);
		};
	}

	public function progress() {
		if (eval.luv._Loop.Loop_Impl_.run((cast this.handle), cast 2)) {
			return sys.thread.NextEventTime.AnyTime(null);
		} else {
			return sys.thread.NextEventTime.Never;
		};
	}

	public function wait(timeout:Null<Float> = null) {
		if (timeout == null) {
			var timer = eval.luv.ResultTools.resolve(eval.luv._Timer.Timer_Impl_.init(this.handle));
			eval.luv._Timer.Timer_Impl_.start(timer, function() {
				eval.luv.ResultTools.resolve(eval.luv._Timer.Timer_Impl_.stop(timer));
				eval.luv._Handle.Handle_Impl_.close(timer, function() {});
			}, Std.int(timeout * 1000), null);
			return eval.luv._Loop.Loop_Impl_.run((cast this.handle), cast 1);
		} else {
			return eval.luv._Loop.Loop_Impl_.run((cast this.handle), cast 1);
		};
	}

	public function loop() {
		this.consumePending(null);
		eval.luv._Loop.Loop_Impl_.run((cast this.handle), cast 0);
	}

	function consumePending(_:Null<eval.luv.Async> = null) {
		var p = this.pending;
		this.pending = [];
		{
			var ` = 0;
			while (` < p.length) {
				var fn = p[`];
				++ `;
				fn();
			};
		};
	}

	@:value(function() { })
	static var noop(default,never):() -> Void = () {};
}