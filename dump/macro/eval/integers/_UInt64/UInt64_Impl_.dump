private class eval.integers._UInt64.UInt64_Impl_ {

	public static var MAX(default,never):eval.integers.UInt64;

	public static var ZERO(default,never):eval.integers.UInt64;

	public static var ONE(default,never):eval.integers.UInt64;

	@:noExpr
	public static function ofInt

	@:noExpr
	public static function ofString

	@:noExpr
	public static function max

	@:noExpr
	public static function min

	@:noExpr
	public static function compare

	@:noExpr
	public static function toInt

	@:noExpr
	public static function toInt64

	@:noExpr
	public static function toString

	@:noExpr
	public static function successor

	@:noExpr
	public static function predecessor

	@:noExpr
	public static function remainder

	@:noExpr
	static function add

	@:noExpr
	static function sub

	@:noExpr
	static function mul

	@:noExpr
	static function div

	@:noExpr
	static function logand

	@:noExpr
	static function logor

	@:noExpr
	static function logxor

	@:noExpr
	static function shift_left

	@:noExpr
	static function shift_right

	@:noExpr
	static function lognot

	@:op(A + B)
	static inline function _add(this:eval.integers.UInt64, u:eval.integers.UInt64) return eval.integers._UInt64.UInt64_Impl_.add(this, u)

	@:op(A - B)
	static inline function _sub(this:eval.integers.UInt64, u:eval.integers.UInt64) return eval.integers._UInt64.UInt64_Impl_.sub(this, u)

	@:op(A * B)
	static inline function _mul(this:eval.integers.UInt64, u:eval.integers.UInt64) return eval.integers._UInt64.UInt64_Impl_.mul(this, u)

	@:op(A / B)
	static inline function _div(this:eval.integers.UInt64, u:eval.integers.UInt64) return eval.integers._UInt64.UInt64_Impl_.div(this, u)

	@:op(A & B)
	static inline function _logand(this:eval.integers.UInt64, u:eval.integers.UInt64) return eval.integers._UInt64.UInt64_Impl_.logand(this, u)

	@:op(A | B)
	static inline function _logor(this:eval.integers.UInt64, u:eval.integers.UInt64) return eval.integers._UInt64.UInt64_Impl_.logor(this, u)

	@:op(A ^ B)
	static inline function _logxor(this:eval.integers.UInt64, u:eval.integers.UInt64) return eval.integers._UInt64.UInt64_Impl_.logxor(this, u)

	@:op(A << B)
	static inline function _shift_left(this:eval.integers.UInt64, i:Int) return eval.integers._UInt64.UInt64_Impl_.shift_left(this, i)

	@:op(A >> B)
	static inline function _shift_right(this:eval.integers.UInt64, i:Int) return eval.integers._UInt64.UInt64_Impl_.shift_right(this, i)

	@:op(~A)
	static inline function _lognot(this:eval.integers.UInt64) return eval.integers._UInt64.UInt64_Impl_.lognot(this)

	@:op(A != B)
	static inline function eq(a:eval.integers.UInt64, b:eval.integers.UInt64) return eval.integers._UInt64.UInt64_Impl_.compare(a, b) != 0

	@:op(A == B)
	static inline function ne(a:eval.integers.UInt64, b:eval.integers.UInt64) return eval.integers._UInt64.UInt64_Impl_.compare(a, b) == 0

	@:op(A < B)
	static inline function lt(a:eval.integers.UInt64, b:eval.integers.UInt64) return eval.integers._UInt64.UInt64_Impl_.compare(a, b) < 0

	@:op(A > B)
	static inline function gt(a:eval.integers.UInt64, b:eval.integers.UInt64) return eval.integers._UInt64.UInt64_Impl_.compare(a, b) > 0

	@:op(A <= B)
	static inline function lte(a:eval.integers.UInt64, b:eval.integers.UInt64) return eval.integers._UInt64.UInt64_Impl_.compare(a, b) <= 0

	@:op(A >= B)
	static inline function gte(a:eval.integers.UInt64, b:eval.integers.UInt64) return eval.integers._UInt64.UInt64_Impl_.compare(a, b) >= 0
}