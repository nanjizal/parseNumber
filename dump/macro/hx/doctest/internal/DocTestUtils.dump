@:noDoc @:dox(hide)
class hx.doctest.internal.DocTestUtils {

	public static inline function currentPos(pos:Null<haxe.PosInfos> = null) return pos

	public static function deepEquals(left:Null<Dynamic>, right:Null<Dynamic>) {
		if (left == right) {
			return true;
		};
		if (left == null || right == null) {
			return false;
		};
		if (Std.is(right, EReg)) {
			return cast (right,EReg).match(Std.string(left));
		};
		if (Std.is(left, String)) {
			return false;
		};
		if (Std.is(left, Array) && Std.is(right, Array)) {
			var leftArr = left;
			var rightArr = right;
			if (leftArr.length == rightArr.length) {
				{
					var ` = 0;
					var `1 = leftArr.length;
					while (` < `1) {
						var i = ` ++;
						if (! hx.doctest.internal.DocTestUtils.deepEquals(leftArr[i], rightArr[i])) {
							return false;
						};
					};
				};
				return true;
			};
			return false;
		};
		if (Std.is(left, haxe.IMap) && Std.is(right, haxe.IMap)) {
			var leftMap = cast left;
			var rightMap = cast right;
			var leftKeys = {
				var ` = [];
				for (k in leftMap.keys()) {
					`.push(k);
				};
				`;
			};
			var rightKeys = {
				var `1 = [];
				for (k in rightMap.keys()) {
					`1.push(k);
				};
				`1;
			};
			if (hx.doctest.internal.DocTestUtils.deepEquals(leftKeys, rightKeys)) {
				{
					var `2 = 0;
					while (`2 < leftKeys.length) {
						var key = leftKeys[`2];
						++ `2;
						if (! hx.doctest.internal.DocTestUtils.deepEquals(leftMap.get(key), rightMap.get(key))) {
							return false;
						};
					};
				};
				return true;
			};
			return false;
		};
		if (Reflect.isEnumValue(left) && Reflect.isEnumValue(right)) {
			var leftEnum = left;
			var rightEnum = right;
			return Type.enumEq(leftEnum, rightEnum);
		};
		if (Reflect.isObject(left) && Reflect.isObject(right)) {
			var clsLeft = Type.getClass(left);
			var clsLeftName = if (clsLeft == null) {
				null;
			} else {
				Type.getClassName(clsLeft);
			};
			var clsRight = Type.getClass(right);
			var clsRightName = if (clsRight == null) {
				null;
			} else {
				Type.getClassName(clsRight);
			};
			if (clsLeftName != clsRightName) {
				return false;
			};
			var clsLeftFields = Reflect.fields(left);
			clsLeftFields.sort(function(x:String, y:String) return if (x > y) {
				1;
			} else {
				if (x == y) {
					0;
				} else {
					-1;
				};
			});
			var clsRightFields = Reflect.fields(right);
			clsRightFields.sort(function(x:String, y:String) return if (x > y) {
				1;
			} else {
				if (x == y) {
					0;
				} else {
					-1;
				};
			});
			if (hx.doctest.internal.DocTestUtils.deepEquals(clsLeftFields, clsRightFields)) {
				{
					var ` = 0;
					while (` < clsLeftFields.length) {
						var fieldName = clsLeftFields[`];
						++ `;
						if (! hx.doctest.internal.DocTestUtils.deepEquals(Reflect.field(left, fieldName), Reflect.field(right, fieldName))) {
							return false;
						};
					};
				};
				return true;
			};
		};
		return false;
	}

	public static function exceptionStackAsString() {
		var stack = haxe._CallStack.CallStack_Impl_.exceptionStack(null);
		var i = -1;
		{
			var ` = 0;
			while (` < stack.length) {
				var elem = stack[`];
				++ `;
				i ++;
				@:ast(switch (elem) {
	case FilePos(elem2, file, line):
		if (file.startsWith("hx/doctest")) {
			stack = stack.slice(0, i);
			break;
		};
		if (elem2 != null) switch (elem2) {
			case Method(classname, method):
				if (classname != null && classname.startsWith("hx.doctest.")) {
					stack = stack.slice(0, i);
					break;
				};			
			default:
		};	
	case Method(classname, method):
		if (classname != null && classname.startsWith("hx.doctest.")) {
			stack = stack.slice(0, i);
			break;
		};	
	default:
}) switch (enumIndex elem) {
					case 2: {
						var `2 = elem[0];
						var `3 = elem[1];
						var `4 = elem[2];
						var `5 = elem[3];
						{
							var elem2 = `2;
							var file = `3;
							var line = `4;
							{
								if (StringTools.startsWith(file, "hx/doctest")) {
									stack = stack.slice(0, i);
									break;
								};
								if (elem2 != null) {
									@:ast(switch (elem2) {
	case Method(classname, method):
		if (classname != null && classname.startsWith("hx.doctest.")) {
			stack = stack.slice(0, i);
			break;
		};	
	default:
}) if (elem2 == null) {} else if (enumIndex elem2 == 3) {
										var ` = elem2[0];
										var `1 = elem2[1];
										{
											var classname = `;
											var method = `1;
											{
												if (classname != null && StringTools.startsWith(classname, "hx.doctest.")) {
													stack = stack.slice(0, i);
													break;
												};
											};
										};
									} else {};
								};
							};
						};
					};
					case 3: {
						var ` = elem[0];
						var `1 = elem[1];
						{
							var classname = `;
							var method = `1;
							{
								if (classname != null && StringTools.startsWith(classname, "hx.doctest.")) {
									stack = stack.slice(0, i);
									break;
								};
							};
						};
					};
					default: {}
				};
			};
		};
		return "  " + haxe._CallStack.CallStack_Impl_.toString(stack).split("\n").join("\n  ") + "\n";
	}

	public static inline function getFileName(filePath:String) return hx.doctest.internal.DocTestUtils.substringAfterLast("/" + StringTools.replace(filePath, "\\", "/"), "/")

	public static function implementsInterface(clazz:haxe.macro.ClassType, interfaceName:String) {
		{
			var ` = 0;
			var `1 = clazz.interfaces;
			while (` < `1.length) {
				var iface = `1[`];
				++ `;
				if (iface.t.toString() == interfaceName) {
					return true;
				};
			};
		};
		return false;
	}

	public static function substringAfter(str:String, sep:String) {
		var foundAt = str.indexOf(sep, null);
		if (foundAt == -1) {
			return "";
		};
		return str.substring(foundAt + sep.length, null);
	}

	public static function substringAfterLast(str:String, sep:String) {
		var foundAt = str.lastIndexOf(sep, null);
		if (foundAt == -1) {
			return "";
		};
		return str.substring(foundAt + sep.length, null);
	}

	public static function substringBefore(str:String, sep:String) {
		var foundAt = str.indexOf(sep, null);
		if (foundAt == -1) {
			return "";
		};
		return str.substring(0, foundAt);
	}

	public static function substringBeforeLast(str:String, sep:String) {
		var foundAt = str.lastIndexOf(sep, null);
		if (foundAt == -1) {
			return "";
		};
		return str.substring(0, foundAt);
	}

	public static function walkDirectory(directory:String, filePattern:EReg, onFile:String -> Void) {
		var files = {
			var _this = sys.FileSystem.readDirectory(directory);
			{
				var ` = [];
				{
					var `1 = 0;
					var `2 = _this;
					while (`1 < `2.length) {
						var v = `2[`1];
						++ `1;
						`.push(function(s:String) {
							return "" + directory + "/" + s;
						}(v));
					};
				};
				`;
			};
		};
		while (files.length > 0) {
			var file = [files.shift()];
			if (file[0] == null) {
				continue;
			};
			if (sys.FileSystem.isDirectory(file[0])) {
				files = files.concat({
					var _this = sys.FileSystem.readDirectory(file[0]);
					{
						var ` = [];
						{
							var `1 = 0;
							var `2 = _this;
							while (`1 < `2.length) {
								var v = `2[`1];
								++ `1;
								`.push(function(s:String) {
									return "" + file[0] + "/" + s;
								}(v));
							};
						};
						`;
					};
				});
			} else {
				file[0] = StringTools.replace(file[0], "\\", "/");
				if (filePattern.match(file[0])) {
					onFile(file[0]);
				};
			};
		};
	}
}