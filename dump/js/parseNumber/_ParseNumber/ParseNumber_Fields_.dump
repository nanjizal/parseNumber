@:directlyUsed @:used
private class parseNumber._ParseNumber.ParseNumber_Fields_ {

	@:value({ allowScientific : false, allowUnderscore : false, allowComma : false })
	public static function parseTest(no:String, allowComma:Bool = false, allowUnderscore:Bool = false, allowScientific:Bool = false) {
		`trace("result '" + parseNumber._ParseNumber.ParseNumber_Fields_.parse(no) + "'", {fileName : "src/parseNumber/ParseNumber.hx", lineNumber : 28, className : "parseNumber._ParseNumber.ParseNumber_Fields_", methodName : "parseTest"});
	}

	public static function parseFloat(no:String) {
		Std.parseFloat(no);
	}

	public static function parseInt(no:String) {
		Std.parseFloat(no);
	}

	@:value({ allowScientific : false, allowUnderscore : false, allowComma : false })
	public static function parse(no:String, allowComma:Bool = false, allowUnderscore:Bool = false, allowScientific:Bool = false) {
		var str = new parseNumber.StringCodeIterator(no);
		var temp = "";
		var count = 0;
		var isNumber = true;
		var dotCount = 0;
		var hasX = false;
		var isScientific = false;
		str.next();
		@:loopLabel(1) while ((str.hasNext())) {
			if ((count == 0)) {
				if ((str.c == 32)) {
					count = 0;
					str.next();
					continue;
				} else if ((str.c == 45)) {
					str.addChar();
					str.next();
					++ count;
					continue;
				};
			};
			if ((count == 1)) {
				if (((str.c == 120 || str.c == 88) && str.toStr() == "0")) {
					str.addChar();
					str.next();
					hasX = true;
					++ count;
					continue;
				} else if ((str.toStr() == "0" && str.c != 46)) str.b = new StringBuf();
			};
			if ((str.c == 95 && allowUnderscore)) {
				str.next();
				continue;
			};
			if ((str.c == 44 && allowComma)) {
				str.next();
				continue;
			};
			switch ((str.c)) {
				case 32: {
					while ((str.hasNext())) {
						if ((str.c != 32)) {
							isNumber = false;
							break;
						};
						str.next();
					};
					@:loopLabel(1) break;
				};
				case 45: if ((isScientific == true)) str.addChar() else {
					isNumber = false;
					@:loopLabel(1) break;
				};
				case 46: {
					if ((dotCount == 0 && ! hasX)) str.addChar() else {
						isNumber = false;
						@:loopLabel(1) break;
					};
					++ dotCount;
				};
				case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57: str.addChar();
				case 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102: if ((hasX)) {
					if ((count < "0xFFffFFf".length)) str.addChar() else {
						isNumber = false;
						@:loopLabel(1) break;
					};
				} else if ((allowScientific)) {
					if ((str.c == 101 || str.c == 69)) {
						var letters = str.str;
						var someNumerics = false;
						var curPos = str.pos;
						{
							var _g = str.pos;
							var _g1 = letters.length;
							@:loopLabel(3) while ((_g < _g1)) {
								var i = _g ++;
								var no = StringTools.fastCodeAt(letters, i);
								curPos = i;
								switch ((no)) {
									case 45: if ((i != str.pos)) {
										isNumber = false;
										@:loopLabel(3) break;
									};
									case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57: someNumerics = true;
									default: @:loopLabel(3) break
								};
							};
						};
						if ((someNumerics == false)) isNumber = false;
						if ((isNumber == false)) @:loopLabel(1) break;
						{
							var _g2 = curPos;
							var _g3 = letters.length;
							while ((_g2 < _g3)) {
								var i1 = _g2 ++;
								if ((i1 != 32)) break;
							};
						};
						if ((isNumber == false)) @:loopLabel(1) break else {
							isScientific = true;
							str.addChar();
						};
					} else {
						isNumber = false;
						@:loopLabel(1) break;
					};
				} else {
					isNumber = false;
					@:loopLabel(1) break;
				};
				default: {
					isNumber = false;
					@:loopLabel(1) break;
				}
			};
			++ count;
			str.next();
		};
		if ((count == 0)) isNumber = false;
		if ((isNumber)) return str.toStr() else return "NaN";
	}
}