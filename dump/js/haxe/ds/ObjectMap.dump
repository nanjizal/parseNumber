@:keep @:directlyUsed @:used @:coreApi
class haxe.ds.ObjectMap<K:{ }, V> implements haxe.IMap<haxe.ds.ObjectMap.K, haxe.ds.ObjectMap.V> {

	public function new() {
		this.h = {__keys__ : {}};
	}

	var h:{ __keys__ : { } };

	public function set(key:haxe.ds.ObjectMap.K, value:haxe.ds.ObjectMap.V) {
		var id = haxe.ds.ObjectMap.getId(key);
		if ((id == null)) id = haxe.ds.ObjectMap.assignId(key);
		js.Syntax.code("{0}[{1}] = {2}", this.h, id, value);
		js.Syntax.code("{0}[{1}] = {2}", this.h.__keys__, id, key);
	}

	@:has_untyped
	public inline function get(key:haxe.ds.ObjectMap.K) {
		return this.h[haxe.ds.ObjectMap.getId(key)];
	}

	@:has_untyped
	public inline function exists(key:haxe.ds.ObjectMap.K) {
		return this.h.__keys__[haxe.ds.ObjectMap.getId(key)] != null;
	}

	@:has_untyped
	public function keys() {
		var a = [];
		{
			js.Syntax.code("for( var key in this.h.__keys__ ) {");
			if ((this.h.hasOwnProperty(key))) a.push(this.h.__keys__[key]);
			js.Syntax.code("}");
		};
		return new haxe.iterators.ArrayIterator(a);
	}

	static var count:Int;

	static inline function assignId(obj:{ }) {
		return js.Syntax.code("({0}.__id__ = {1})", obj, js.Lib.getNextHaxeUID());
	}

	@:has_untyped
	static inline function getId(obj:{ }) {
		return obj.__id__;
	}

	static function __init__() haxe.ds.ObjectMap.count = 0
}