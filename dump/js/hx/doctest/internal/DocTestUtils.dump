@:directlyUsed @:used @:noDoc @:dox(hide)
class hx.doctest.internal.DocTestUtils {

	public static inline function currentPos(pos:Null<haxe.PosInfos> = null) {
		return pos;
	}

	public static function deepEquals(left:Null<Dynamic>, right:Null<Dynamic>) {
		if ((left == right)) return true;
		if ((left == null || right == null)) return false;
		if ((js.Syntax.instanceof(right, EReg))) return (cast (right,EReg)).match(Std.string(left));
		if ((js.Syntax.typeof(left) == "string")) return false;
		if ((js.Syntax.instanceof(left, Array) && js.Syntax.instanceof(right, Array))) {
			var leftArr = left;
			var rightArr = right;
			if ((leftArr.length == rightArr.length)) {
				{
					var _g = 0;
					var _g1 = leftArr.length;
					while ((_g < _g1)) {
						var i = _g ++;
						if ((! hx.doctest.internal.DocTestUtils.deepEquals(leftArr[i], rightArr[i]))) return false;
					};
				};
				return true;
			};
			return false;
		};
		if ((js.Boot.__implements(left, haxe.IMap) && js.Boot.__implements(right, haxe.IMap))) {
			var leftMap = cast left;
			var rightMap = cast right;
			var _g = [];
			{
				var k = leftMap.keys();
				while ((k.hasNext())) {
					var k1 = k.next();
					_g.push(k1);
				};
			};
			var leftKeys = _g;
			var _g = [];
			{
				var k = rightMap.keys();
				while ((k.hasNext())) {
					var k1 = k.next();
					_g.push(k1);
				};
			};
			var rightKeys = _g;
			if ((hx.doctest.internal.DocTestUtils.deepEquals(leftKeys, rightKeys))) {
				{
					var _g = 0;
					while ((_g < leftKeys.length)) {
						var key = leftKeys[_g];
						++ _g;
						if ((! hx.doctest.internal.DocTestUtils.deepEquals(leftMap.get(key), rightMap.get(key)))) return false;
					};
				};
				return true;
			};
			return false;
		};
		if ((Reflect.isEnumValue(left) && Reflect.isEnumValue(right))) {
			var leftEnum = left;
			var rightEnum = right;
			return Type.enumEq(leftEnum, rightEnum);
		};
		if ((Reflect.isObject(left) && Reflect.isObject(right))) {
			var clsLeft = Type.getClass(left);
			var clsLeftName = if ((clsLeft == null)) null else Type.getClassName(clsLeft);
			var clsRight = Type.getClass(right);
			var clsRightName = if ((clsRight == null)) null else Type.getClassName(clsRight);
			if ((clsLeftName != clsRightName)) return false;
			var clsLeftFields = Reflect.fields(left);
			clsLeftFields.sort(function(x:String, y:String) {
				if ((x > y)) return 1 else if ((x == y)) return 0 else return -1;
			});
			var clsRightFields = Reflect.fields(right);
			clsRightFields.sort(function(x:String, y:String) {
				if ((x > y)) return 1 else if ((x == y)) return 0 else return -1;
			});
			if ((hx.doctest.internal.DocTestUtils.deepEquals(clsLeftFields, clsRightFields))) {
				{
					var _g = 0;
					while ((_g < clsLeftFields.length)) {
						var fieldName = clsLeftFields[_g];
						++ _g;
						if ((! hx.doctest.internal.DocTestUtils.deepEquals(Reflect.field(left, fieldName), Reflect.field(right, fieldName)))) return false;
					};
				};
				return true;
			};
		};
		return false;
	}

	public static function exceptionStackAsString() {
		var stack = haxe._CallStack.CallStack_Impl_.exceptionStack();
		var i = -1;
		{
			var _g = 0;
			@:loopLabel(1) while ((_g < stack.length)) {
				var elem = stack[_g];
				++ _g;
				++ i;
				switch ((enumIndex elem)) {
					case 2: {
						var _g1 = elem[3];
						{
							var elem2 = elem[0];
							var file = elem[1];
							var line = elem[2];
							{
								if ((StringTools.startsWith(file, "hx/doctest"))) {
									stack = stack.slice(0, i);
									@:loopLabel(1) break;
								};
								if ((elem2 != null)) {
									if ((elem2 != null)) {
										if ((enumIndex elem2 == 3)) {
											var classname = elem2[0];
											var method = elem2[1];
											if ((classname != null && StringTools.startsWith(classname, "hx.doctest."))) {
												stack = stack.slice(0, i);
												@:loopLabel(1) break;
											};
										};
									};
								};
							};
						};
					};
					case 3: {
						var classname1 = elem[0];
						var method1 = elem[1];
						if ((classname1 != null && StringTools.startsWith(classname1, "hx.doctest."))) {
							stack = stack.slice(0, i);
							@:loopLabel(1) break;
						};
					};
					default: {}
				};
			};
		};
		return "  " + haxe._CallStack.CallStack_Impl_.toString(stack).split("\n").join("\n  ") + "\n";
	}

	public static inline function getFileName(filePath:String) {
		return hx.doctest.internal.DocTestUtils.substringAfterLast("/" + StringTools.replace(filePath, "\\", "/"), "/");
	}

	public static function substringAfter(str:String, sep:String) {
		var foundAt = str.indexOf(sep);
		if ((foundAt == -1)) return "";
		return str.substring(foundAt + sep.length);
	}

	public static function substringAfterLast(str:String, sep:String) {
		var foundAt = str.lastIndexOf(sep);
		if ((foundAt == -1)) return "";
		return str.substring(foundAt + sep.length);
	}

	public static function substringBefore(str:String, sep:String) {
		var foundAt = str.indexOf(sep);
		if ((foundAt == -1)) return "";
		return str.substring(0, foundAt);
	}

	public static function substringBeforeLast(str:String, sep:String) {
		var foundAt = str.lastIndexOf(sep);
		if ((foundAt == -1)) return "";
		return str.substring(0, foundAt);
	}
}